// Generated by dts-bundle-generator v7.1.0

export interface ClickControl extends ControlBase {
	how: "click";
	selector: string;
}
export interface ValueControl extends ControlBase {
	how: "value";
	selector: string;
	value: string;
}
export interface KeyControl extends ControlBase {
	how: "key";
	key: string;
}
export type WebControl = ClickControl | ValueControl | KeyControl;
export interface PageTarget extends TargetBase<"page"> {
	component: "title" | "text" | "html";
}
export type SelectorType = {
	text: string;
	html: string;
	count: number;
};
export type SelectorProp = keyof SelectorType;
export interface SelectorTarget<K extends SelectorProp> extends TargetBase<"selector"> {
	selector: string;
	component: K;
}
export type WebAssertTarget = PageTarget | SelectorTarget<SelectorProp>;
export type Category = "web";
export interface ControlBase {
	type: "control";
}
export interface TargetBase<T extends string> {
	target: T;
}
export interface Production {
	control: ControlBase;
	assert: TargetBase<string>;
}
export type Implements<T, U extends T> = {};
export interface WebProduction extends Implements<Production, WebProduction> {
	control: WebControl;
	assert: WebAssertTarget;
}
export interface AllProduction extends Implements<Record<Category, Production>, AllProduction> {
	web: WebProduction;
}
export interface Union<A extends readonly [
	RuntypeBase,
	...RuntypeBase[]
]> extends Runtype<{
	[K in keyof A]: A[K] extends RuntypeBase ? Static<A[K]> : unknown;
}[number]> {
	tag: "union";
	alternatives: A;
	match: Match<A>;
}
declare function Union<T extends readonly [
	RuntypeBase,
	...RuntypeBase[]
]>(...alternatives: T): Union<T>;
export interface Match<A extends readonly [
	RuntypeBase,
	...RuntypeBase[]
]> {
	<Z>(...a: {
		[K in keyof A]: A[K] extends RuntypeBase ? Case<A[K], Z> : never;
	}): Matcher<A, Z>;
}
export declare type Case<T extends RuntypeBase, Result> = (v: Static<T>) => Result;
export declare type Matcher<A extends readonly [
	RuntypeBase,
	...RuntypeBase[]
], Z> = (x: {
	[K in keyof A]: A[K] extends RuntypeBase<infer Type> ? Type : unknown;
}[number]) => Z;
/**
 * The super type of all literal types.
 */
export declare type LiteralBase = undefined | null | boolean | number | bigint | string;
export interface Literal<A extends LiteralBase> extends Runtype<A> {
	tag: "literal";
	value: A;
}
declare function Literal<A extends LiteralBase>(valueBase: A): Literal<A>;
declare const Null: Literal<null>;
export declare type ConstraintCheck<A extends RuntypeBase> = (x: Static<A>) => boolean | string;
export interface Constraint<A extends RuntypeBase, T extends Static<A> = Static<A>, K = unknown> extends Runtype<T> {
	tag: "constraint";
	underlying: A;
	constraint(x: Static<A>): boolean | string;
	name?: string;
	args?: K;
}
declare function Constraint<A extends RuntypeBase, T extends Static<A> = Static<A>, K = unknown>(underlying: A, constraint: ConstraintCheck<A>, options?: {
	name?: string;
	args?: K;
}): Constraint<A, T, K>;
export interface Constructor<V> {
	new (...args: any[]): V;
}
export declare type Reflect = ({
	tag: "unknown";
} & Runtype) | ({
	tag: "never";
} & Runtype<never>) | ({
	tag: "void";
} & Runtype<void>) | ({
	tag: "boolean";
} & Runtype<boolean>) | ({
	tag: "number";
} & Runtype<number>) | ({
	tag: "bigint";
} & Runtype<bigint>) | ({
	tag: "string";
} & Runtype<string>) | ({
	tag: "symbol";
	key: string | undefined;
} & Runtype<symbol>) | ({
	tag: "symbol";
	(key: string | undefined): Runtype<symbol>;
} & Runtype<symbol>) | ({
	tag: "literal";
	value: LiteralBase;
} & Runtype<LiteralBase>) | ({
	tag: "template";
	strings: string[];
	runtypes: Runtype<LiteralBase>[];
} & Runtype<string>) | ({
	tag: "array";
	element: Reflect;
	isReadonly: boolean;
} & Runtype<ReadonlyArray<unknown>>) | ({
	tag: "record";
	fields: {
		[_: string]: Reflect;
	};
	isPartial: boolean;
	isReadonly: boolean;
} & Runtype<{
	readonly [_ in string]: unknown;
}>) | ({
	tag: "dictionary";
	key: "string" | "number" | "symbol";
	value: Reflect;
} & Runtype<{
	[_: string]: unknown;
}>) | ({
	tag: "tuple";
	components: Reflect[];
} & Runtype<unknown[]>) | ({
	tag: "union";
	alternatives: Reflect[];
} & Runtype) | ({
	tag: "intersect";
	intersectees: Reflect[];
} & Runtype) | ({
	tag: "optional";
	underlying: Reflect;
} & Runtype) | ({
	tag: "function";
} & Runtype<(...args: any[]) => any>) | ({
	tag: "constraint";
	underlying: Reflect;
	constraint: ConstraintCheck<Runtype<never>>;
	args?: any;
	name?: string;
} & Runtype) | ({
	tag: "instanceof";
	ctor: Constructor<unknown>;
} & Runtype) | ({
	tag: "brand";
	brand: string;
	entity: Reflect;
} & Runtype);
declare const RuntypeSymbol: unique symbol;
/**
 * A runtype determines at runtime whether a value conforms to a type specification.
 */
export interface RuntypeBase<A = unknown> {
	/**
	 * Verifies that a value conforms to this runtype. When given a value that does
	 * not conform to the runtype, throws an exception.
	 */
	assert(x: any): asserts x is A;
	/**
	 * Verifies that a value conforms to this runtype. If so, returns the same value,
	 * statically typed. Otherwise throws an exception.
	 */
	check(x: any): A;
	/**
	 * Validates that a value conforms to this type, and returns a result indicating
	 * success or failure (does not throw).
	 */
	validate(x: any): Result<A>;
	/**
	 * A type guard for this runtype.
	 */
	guard(x: any): x is A;
	/**
	 * Convert this to a Reflect, capable of introspecting the structure of the type.
	 */
	readonly reflect: Reflect;
	readonly _falseWitness: A;
	readonly [RuntypeSymbol]: true;
}
/**
 * A runtype determines at runtime whether a value conforms to a type specification.
 */
export interface Runtype<A = unknown> extends RuntypeBase<A> {
	/**
	 * Union this Runtype with another.
	 */
	Or<B extends RuntypeBase>(B: B): Union<[
		this,
		B
	]>;
	/**
	 * Intersect this Runtype with another.
	 */
	And<B extends RuntypeBase>(B: B): Intersect<[
		this,
		B
	]>;
	/**
	 * Optionalize this Runtype.
	 */
	optional(): Optional<this>;
	/**
	 * Union this Runtype with `Null`.
	 */
	nullable(): Union<[
		this,
		typeof Null
	]>;
	/**
	 * Use an arbitrary constraint function to validate a runtype, and optionally
	 * to change its name and/or its static type.
	 *
	 * @template T - Optionally override the static type of the resulting runtype
	 * @param {(x: Static<this>) => boolean | string} constraint - Custom function
	 * that returns `true` if the constraint is satisfied, `false` or a custom
	 * error message if not.
	 * @param [options]
	 * @param {string} [options.name] - allows setting the name of this
	 * constrained runtype, which is helpful in reflection or diagnostic
	 * use-cases.
	 */
	withConstraint<T extends Static<this>, K = unknown>(constraint: ConstraintCheck<this>, options?: {
		name?: string;
		args?: K;
	}): Constraint<this, T, K>;
	/**
	 * Helper function to convert an underlying Runtype into another static type
	 * via a type guard function.  The static type of the runtype is inferred from
	 * the type of the guard function.
	 *
	 * @template T - Typically inferred from the return type of the type guard
	 * function, so usually not needed to specify manually.
	 * @param {(x: Static<this>) => x is T} guard - Type guard function (see
	 * https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards)
	 *
	 * @param [options]
	 * @param {string} [options.name] - allows setting the name of this
	 * constrained runtype, which is helpful in reflection or diagnostic
	 * use-cases.
	 */
	withGuard<T extends Static<this>, K = unknown>(guard: (x: Static<this>) => x is T, options?: {
		name?: string;
		args?: K;
	}): Constraint<this, T, K>;
	/**
	 * Adds a brand to the type.
	 */
	withBrand<B extends string>(brand: B): Brand<B, this>;
}
/**
 * Obtains the static type associated with a Runtype.
 */
export declare type Static<A extends RuntypeBase> = A["_falseWitness"];
/**
 * A detailed object enumerating where the validation failed exactly.
 */
export declare type Details = (string | Details)[] | {
	[key in string | number | symbol]: string | Details;
};
/**
 * A predefined error code indicating what type of failure has occured.
 */
export declare type Failcode = typeof Failcode[keyof typeof Failcode];
declare const Failcode: {
	/** The type of the received primitive value is incompatible with expected one. */
	readonly TYPE_INCORRECT: "TYPE_INCORRECT";
	/** The received primitive value is incorrect. */
	readonly VALUE_INCORRECT: "VALUE_INCORRECT";
	/** The key of the property is incorrect. */
	readonly KEY_INCORRECT: "KEY_INCORRECT";
	/** One or more elements or properties of the received object are incorrect. */
	readonly CONTENT_INCORRECT: "CONTENT_INCORRECT";
	/** One or more arguments passed to the function is incorrect. */
	readonly ARGUMENT_INCORRECT: "ARGUMENT_INCORRECT";
	/** The value returned by the function is incorrect. */
	readonly RETURN_INCORRECT: "RETURN_INCORRECT";
	/** The received value does not fulfill the constraint. */
	readonly CONSTRAINT_FAILED: "CONSTRAINT_FAILED";
	/** The property must be present but missing. */
	readonly PROPERTY_MISSING: "PROPERTY_MISSING";
	/** The property must not be present but present. */
	readonly PROPERTY_PRESENT: "PROPERTY_PRESENT";
	/** The value must not be present but present. */
	readonly NOTHING_EXPECTED: "NOTHING_EXPECTED";
};
/**
 * A successful validation result.
 */
export declare type Success<T> = {
	/**
	 * A tag indicating success.
	 */
	success: true;
	/**
	 * The original value, cast to its validated type.
	 */
	value: T;
};
/**
 * A failed validation result.
 */
export declare type Failure = {
	/**
	 * A tag indicating failure.
	 */
	success: false;
	/**
	 * An error code assigned to this type of error.
	 */
	code: Failcode;
	/**
	 * A message indicating the reason why the validation failed.
	 */
	message: string;
	/**
	 * A detailed object enumerating where the validation failed exactly.
	 */
	details?: Details;
};
/**
 * The result of a type validation.
 */
export declare type Result<T> = Success<T> | Failure;
export interface Optional<R extends RuntypeBase> extends Runtype<Static<R> | undefined> {
	tag: "optional";
	underlying: R;
}
declare function Optional<R extends RuntypeBase>(runtype: R): Optional<R>;
export interface Intersect<A extends readonly [
	RuntypeBase,
	...RuntypeBase[]
]> extends Runtype<{
	[K in keyof A]: A[K] extends RuntypeBase ? (parameter: Static<A[K]>) => any : unknown;
}[number] extends (k: infer I) => void ? I : never> {
	tag: "intersect";
	intersectees: A;
}
declare function Intersect<A extends readonly [
	RuntypeBase,
	...RuntypeBase[]
]>(...intersectees: A): Intersect<A>;
declare const RuntypeName: unique symbol;
export interface RuntypeBrand<B extends string> {
	[RuntypeName]: B;
}
export interface Brand<B extends string, A extends RuntypeBase> extends Runtype<Static<A> & RuntypeBrand<B>> {
	tag: "brand";
	brand: B;
	entity: A;
}
declare function Brand<B extends string, A extends RuntypeBase>(brand: B, entity: A): any;
declare const Call: unique symbol;
declare const Produced: unique symbol;
export type CallSig = {
	parameters?: readonly Runtype[];
	returns?: Runtype;
};
export type OrDefault<T, D> = T extends {} ? T : D;
export type StaticMap<T extends readonly Runtype[]> = T extends readonly [
	infer Car extends Runtype,
	...infer Cdr extends Runtype[]
] ? [
	Static<Car>,
	...StaticMap<Cdr>
] : [
];
declare function withCall<A, C extends CallSig>(this: Runtype<A>, call: C): Runtype<A & StaticCallSig<C>>;
export interface IProduction<C extends Category, T extends "assert" | "control"> {
	type: `${C}.${T}`;
	result: (...args: any[]) => AllProduction[C][T];
}
declare function produces<A, C extends Category, T extends "assert" | "control">(this: Runtype<A>, type: `${C}.${T}`, result: (...args: any[][]) => AllProduction[C][T]): Runtype<A>;
export type StaticLesser<T> = T extends Runtype ? Static<T> : undefined;
export type StaticCallSig<C extends CallSig> = (...args: StaticMap<OrDefault<C["parameters"], [
]>>) => OrDefault<StaticLesser<C["returns"]>, void>;
declare const globals: {
	readonly $: Runtype<{
		key: (args_0: "Q" | "a" | "b" | "i" | "p" | "q" | "s" | "u" | "g" | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "Power" | "Eject" | "Abort" | "Help" | "Backspace" | "Tab" | "Numpad5" | "NumpadEnter" | "Enter" | "\r" | "\n" | "ShiftLeft" | "ShiftRight" | "ControlLeft" | "ControlRight" | "AltLeft" | "AltRight" | "Pause" | "CapsLock" | "Escape" | "Convert" | "NonConvert" | "Space" | "Numpad9" | "PageUp" | "Numpad3" | "PageDown" | "End" | "Numpad1" | "Home" | "Numpad7" | "ArrowLeft" | "Numpad4" | "Numpad8" | "ArrowUp" | "ArrowRight" | "Numpad6" | "Numpad2" | "ArrowDown" | "Select" | "Open" | "PrintScreen" | "Insert" | "Numpad0" | "Delete" | "NumpadDecimal" | "Digit0" | "Digit1" | "Digit2" | "Digit3" | "Digit4" | "Digit5" | "Digit6" | "Digit7" | "Digit8" | "Digit9" | "KeyA" | "KeyB" | "KeyC" | "KeyD" | "KeyE" | "KeyF" | "KeyG" | "KeyH" | "KeyI" | "KeyJ" | "KeyK" | "KeyL" | "KeyM" | "KeyN" | "KeyO" | "KeyP" | "KeyQ" | "KeyR" | "KeyS" | "KeyT" | "KeyU" | "KeyV" | "KeyW" | "KeyX" | "KeyY" | "KeyZ" | "MetaLeft" | "MetaRight" | "ContextMenu" | "NumpadMultiply" | "NumpadAdd" | "NumpadSubtract" | "NumpadDivide" | "F1" | "F2" | "F3" | "F4" | "F5" | "F6" | "F7" | "F8" | "F9" | "F10" | "F11" | "F12" | "F13" | "F14" | "F15" | "F16" | "F17" | "F18" | "F19" | "F20" | "F21" | "F22" | "F23" | "F24" | "NumLock" | "ScrollLock" | "AudioVolumeMute" | "AudioVolumeDown" | "AudioVolumeUp" | "MediaTrackNext" | "MediaTrackPrevious" | "MediaStop" | "MediaPlayPause" | "Semicolon" | "Equal" | "NumpadEqual" | "Comma" | "Minus" | "Period" | "Slash" | "Backquote" | "BracketLeft" | "Backslash" | "BracketRight" | "Quote" | "AltGraph" | "Props" | "Cancel" | "Clear" | "Shift" | "Control" | "Alt" | "Accept" | "ModeChange" | " " | "Print" | "Execute" | "\0" | "c" | "d" | "e" | "f" | "h" | "j" | "k" | "l" | "m" | "n" | "o" | "r" | "t" | "v" | "w" | "x" | "y" | "z" | "Meta" | "*" | "+" | "-" | "/" | ";" | "=" | "," | "." | "`" | "[" | "\\" | "]" | "'" | "Attn" | "CrSel" | "ExSel" | "EraseEof" | "Play" | "ZoomOut" | ")" | "!" | "@" | "#" | "$" | "%" | "^" | "&" | "(" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | ":" | "<" | "_" | ">" | "?" | "~" | "{" | "|" | "}" | "\"" | "SoftLeft" | "SoftRight" | "Camera" | "Call" | "EndCall" | "VolumeDown" | "VolumeUp") => void;
		html: string;
		title: string;
		text: string;
	} & ((args_0: string) => {
		input: (args_0: string) => void;
		html: string;
		text: string;
		click: () => void;
		count: number;
	})>;
};
export type Globals = {
	[K in keyof typeof globals]: Static<typeof globals[K]>;
};
declare global {
	const $: Globals["$"];
}

export {};
